<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: JavaScript | An Unexpected Coder]]></title>
  <link href="http://anunexpectedcoder.com/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://anunexpectedcoder.com/"/>
  <updated>2015-09-24T16:18:27-04:00</updated>
  <id>http://anunexpectedcoder.com/</id>
  <author>
    <name><![CDATA[Catherine Meyers]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Slide Slide Slippity Slide]]></title>
    <link href="http://anunexpectedcoder.com/blog/2015/09/23/slide-slide-slippity-slide/"/>
    <updated>2015-09-23T16:47:44-04:00</updated>
    <id>http://anunexpectedcoder.com/blog/2015/09/23/slide-slide-slippity-slide</id>
    <content type="html"><![CDATA[<h2>How to Create a Slide Presentation in 150 Lines of JavaScript</h2>

<p>Recently a client needed a website that could be used both as a presentation tool (like a Keynote or PowerPoint presentation) and as a stand-alone website to be sent to possible investors to scroll through.</p>

<p>There are a lot of great libraries out there that help you mimic the functionality of a Keynote presentation. I took a look at <a href="http://flowtime-js.marcolago.com/" target="_blank">flowtime</a>, <a href="http://lab.hakim.se/reveal-js/#/" target="_blank">reveal.js</a>, and <a href="http://impress.github.io/impress.js/#/bored" target="_blank">impress.js</a>. But, these libraries are big and seemed like overkill for what I needed to do. Also, I really wanted to see if I could build this on my own.</p>

<p>First I made my panels. I broke up the site into sections (literally &mdash; using <code>&lt;section&gt;&lt;/section&gt;</code> tags) and made each section <code>height = 100vh</code>. Actually, I had to make room for my fixed nav up top, so it was really <code>height = calc(100vh - 103)</code>. Now that I had things looking the way they should, I needed to make them act the way they should.</p>

<p>I soon realized that my biggest challenge was to designate which section was the current panel so we could find the previous and next panels. I found this <a href="http://stackoverflow.com/questions/22659903/jquery-scroll-to-next-prev-section-by-keyup-keydown" target="_blank">stackoverflow answer</a> that seemed like it could be a solution. It used the <a href="https://github.com/customd/jquery-visible" target="_blank">jquery-visible plugin</a> to tell if a section was in view and then found next and previous based on that. However, after the better part of a day going down that path, I realized it wouldn&rsquo;t work for my needs. Before giving up, I asked another engineer if he had any idea how I could make this work (shout out, Kevin!). He said, &ldquo;Why don&rsquo;t you try using waypoints?&rdquo; YES! Why didn&rsquo;t I think of that?</p>

<p><a href="http://imakewebthings.com/waypoints/" target="_blank">Waypoints</a> is a great library that lets you trigger a function on scroll. I could make each section have its own waypoint where it gets the class &lsquo;currentPanel&rsquo; as soon as it&rsquo;s almost to the top of the screen.</p>

<p>```javascript
getCurrentPanel: function() {
  $(&lsquo;section&rsquo;).each(function(){</p>

<pre><code>var index = $(this).index();
var nextIndex = index + 1;
var prevIndex = index - 1;
var waypointsDown = new Waypoint({
  element: $('.section'+index),
  handler: function(direction) {
    if (direction === 'down') {
      $('.section'+index).addClass('currentPanel');
      if (prevIndex &gt; 0) {
        $('.section'+prevIndex).removeClass('currentPanel');
      }
    }
  },
  offset: 200
});
var waypointsUp = new Waypoint({
  element: $('.section'+index),
  handler: function(direction) {
    if (direction === 'up') {
      $('.section'+index).addClass('currentPanel');
      if ($('.section'+index).length &gt; 0) {
        $('.section'+nextIndex).removeClass('currentPanel');
      }
    }
  },
  offset: 100
});
</code></pre>

<p>  });
}
```</p>

<p>In that function, I&rsquo;m looping through all the sections and assigning a waypoint to each based on its index. I set up my HTML so that each section had a class based on its position (i.e. the first section has a class of &lsquo;section1&rsquo;). As you&rsquo;re scrolling down, a section will get the class &lsquo;currentPanel&rsquo; when it&rsquo;s 200px from the top. On the way back up, a section would get that class 100px from the top. I&rsquo;m also making sure that as the &lsquo;currentPanel&rsquo; class is added to one section, it is removed from the section that just had it.</p>

<p>Now that I could find the current panel, I needed to designate next and previous panels and animate the scroll.</p>

<p>```javascript
scrollToElement: function(panel) {
  $(&lsquo;html, body&rsquo;).animate({</p>

<pre><code>scrollTop: panel.offset().top - 102
</code></pre>

<p>  }, 200);
},</p>

<p>findNext: function() {
  var that = this;
  var $currentPanel = $(&lsquo;.currentPanel&rsquo;);
  var nextPanel = $currentPanel.nextAll(&lsquo;section&rsquo;);
  if (nextPanel.length > 0) {</p>

<pre><code>that.scrollToElement(nextPanel);
</code></pre>

<p>  }
},</p>

<p>findPrev: function() {
  var that = this;
  var $currentPanel = $(&lsquo;.currentPanel&rsquo;);
  var prevPanel = $currentPanel.prevAll(&lsquo;section&rsquo;);
  if (prevPanel.length > 0) {</p>

<pre><code>that.scrollToElement(prevPanel);
</code></pre>

<p>  }
}
```
Now I needed that scroll to happen in response to a presentation clicker. We had <a href="http://www.logitech.com/en-us/product/wireless-presenter-r400?crid=11" target="_blank">this one</a> in the office, so I connected it to my computer and console logged the <a href="https://css-tricks.com/snippets/javascript/javascript-keycodes/" target="_blank">keyCodes</a> to find which it simulated. It was using 33 and 34 (page up and page down). I also added a few more keyCodes in case the client forgot his clicker and needed to use the keyboard to move through the site.</p>

<p>```javascript
slider: function(e) {
  var that = this;
  $(document).on(&lsquo;keydown&rsquo;, function(e){</p>

<pre><code>var $currentPanel = $('.currentPanel');
if (e.keyCode === 40 || e.keyCode === 32 || e.keyCode === 13  || e.keyCode === 34) {
  e.preventDefault();
  that.findNext();
} else if (e.keyCode === 38 || e.keyCode === 33) {
  e.preventDefault();
  that.findPrev();
}
</code></pre>

<p>  });
}
```</p>

<p>Thanks to my &lsquo;getCurrentPanel&rsquo; function, I knew that the panel with the class &lsquo;currentPanel&rsquo; was my current panel, and could fire my &lsquo;findNext&rsquo; or &lsquo;findPrev&rsquo; functions based on whether the keyCodes called for up or down movement. Yay!</p>

<p>On to what I call &lsquo;fragmented&rsquo; panels. By this I mean sections that call for a halt in the movement up and down and instead move through the content inside the panel itself.</p>

<p>```javascript
fragmentedPanel: function(movement) {
  var that = this;
  var currentFragmentedPanel = $(&lsquo;.currentPanel.fragmented&rsquo;);
  var currentFragmentedParts = currentFragmentedPanel.find(&lsquo;.fragmented-part.active&rsquo;);
  currentFragmentedParts.each(function(){</p>

<pre><code>var fragmentIndex = $(this).index();
var nextFragment = fragmentIndex + 1;
var prevFragment = fragmentIndex - 1;
var checkForLast = fragmentIndex + 2;
var checkForFirst = fragmentIndex - 2;
if (movement === 'down') {
  if ($('.currentPanel .fragmented-part.part'+nextFragment).length &gt; 0) {
    if ($('.currentPanel .fragmented-part.part'+checkForLast).length &gt; 0) {
      currentFragmentedParts.removeClass('active');
      $('.currentPanel .fragmented-part.part'+nextFragment).addClass('active');
      currentFragmentedPanel.removeClass('first-fragment');
      currentFragmentedPanel.removeClass('last-fragment');
    } else {
      currentFragmentedParts.removeClass('active');
      $('.currentPanel .fragmented-part.part'+nextFragment).addClass('active');
      currentFragmentedPanel.removeClass('first-fragment');
      currentFragmentedPanel.addClass('last-fragment');
    }
  }
} else if (movement === 'up') {
  if (prevFragment &gt;= 0) {
    if (checkForFirst &gt;= 0) {
      currentFragmentedParts.removeClass('active');
      $('.currentPanel .fragmented-part.part'+prevFragment).addClass('active');
      currentFragmentedPanel.removeClass('first-fragment');
      currentFragmentedPanel.removeClass('last-fragment');
    } else {
      currentFragmentedParts.removeClass('active');
      $('.currentPanel .fragmented-part.part'+prevFragment).addClass('active');
      currentFragmentedPanel.removeClass('last-fragment');
      currentFragmentedPanel.addClass('first-fragment');
    }
  }
}
</code></pre>

<p>  });
}
```</p>

<p>For this code to work, you need to set up your HTML with certain classes. The &lsquo;section&rsquo; will need to get the class &lsquo;fragmented&rsquo;. The parts within that fragmented section need to get two classes: &lsquo;fragmented-part&rsquo; and part+index (i.e. &lsquo;part1&rsquo;).</p>

<p>So here&rsquo;s a weird thing I ran into working with a DOM element&rsquo;s index. When I looped through the fragmented parts' indices, the first element had an index of 0. That&rsquo;s to be expected. However, when I looped through the sections, the first section had an index of 1. I have no idea why that is happening. If anyone knows, please enlighten me. But for now, I&rsquo;m just labeling the first section with &lsquo;section1&rsquo; while the first fragmented-part gets &lsquo;part0&rsquo;.</p>

<p>A big thing in the fragmentedPanel function is to know when you&rsquo;re reaching the end of the fragmented-parts so you can move on to the next slide. That&rsquo;s why I have the &lsquo;checkForLast&rsquo; and &lsquo;checkForFirst&rsquo; variables. With every movement, I&rsquo;m checking to see if an element exists in the next slot.</p>

<p>Great, now we need to update our slider function to halt movement if we see a &lsquo;fragmented&rsquo; section.</p>

<p>```javascript
slider: function(e) {
  var that = this;
  var movement;
  $(document).on(&lsquo;keydown&rsquo;, function(e){</p>

<pre><code>var $currentPanel = $('.currentPanel');
if (e.keyCode === 40 || e.keyCode === 32 || e.keyCode === 13  || e.keyCode === 34) {
  e.preventDefault();
  if ( !($currentPanel.hasClass('fragmented')) || $currentPanel.hasClass('last-fragment') ) {
    that.findNext();
  } else {
    movement = 'down';
    that.fragmentedPanel(movement);
  }
} else if (e.keyCode === 38 || e.keyCode === 33) {
  e.preventDefault();
  if ( !($currentPanel.hasClass('fragmented')) || $currentPanel.hasClass('first-fragment') ) {
    that.findPrev();
  } else {
    movement = 'up';
    that.fragmentedPanel(movement);
  }
}
</code></pre>

<p>  });
}
```</p>

<p>That&rsquo;s pretty much it. I hope this makes some kind of sense to you. You can take a look at the <a href="https://github.com/ccmeyers/slide-presentation" target="_blank">full code here</a> and a <a href="http://slide-presentation.divshot.io/" target="_blank">demo here</a>.</p>

<p>And in honor of this blog post&rsquo;s title. I leave you with a little Coolio circa 1994.</p>

<iframe width="420" height="315" src="https://www.youtube.com/embed/cbhkuu4e0iw" frameborder="0" allowfullscreen></iframe>

]]></content>
  </entry>
  
</feed>
