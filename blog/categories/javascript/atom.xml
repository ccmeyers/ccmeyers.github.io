<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: JavaScript | An Unexpected Coder]]></title>
  <link href="http://anunexpectedcoder.com/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://anunexpectedcoder.com/"/>
  <updated>2016-03-17T09:29:52-07:00</updated>
  <id>http://anunexpectedcoder.com/</id>
  <author>
    <name><![CDATA[Catherine Meyers]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Slide Slide Slippity Slide]]></title>
    <link href="http://anunexpectedcoder.com/blog/2015/09/23/slide-slide-slippity-slide/"/>
    <updated>2015-09-23T13:47:44-07:00</updated>
    <id>http://anunexpectedcoder.com/blog/2015/09/23/slide-slide-slippity-slide</id>
    <content type="html"><![CDATA[<h2>How to Create a Slide Presentation with JavaScript</h2>

<p>Recently a client needed a website that could be used both as a presentation tool (like a Keynote or PowerPoint presentation) and as a stand-alone website to be sent to possible investors to scroll through.</p>

<p>There are a lot of great libraries out there that help you mimic the functionality of a Keynote presentation. I took a look at <a href="http://flowtime-js.marcolago.com/" target="_blank">flowtime</a>, <a href="http://lab.hakim.se/reveal-js/#/" target="_blank">reveal.js</a>, and <a href="http://impress.github.io/impress.js/#/bored" target="_blank">impress.js</a>. But, these libraries are big and seemed like overkill for what I needed to do. Also, I really wanted to see if I could build this on my own.</p>

<p>(If you want to jump ahead to the finished product, here&rsquo;s <a href="http://anunexpectedcoder.com/slide-presentation/" target="_blank">an example</a> of what I built along with <a href="https://github.com/ccmeyers/slide-presentation" target="_blank">the code on github</a>.)</p>

<p>First I made my panels. I broke up the site into sections (literally &mdash; using <code>&lt;section&gt;&lt;/section&gt;</code> tags) and made each section <code>height = 100vh</code>. Actually, I had to make room for my fixed nav up top, so it was really <code>height = calc(100vh - 102)</code>. Now that I had things looking the way they should, I needed to make them act the way they should.</p>

<p>I soon realized that my biggest challenge was to designate which section was the current panel so we could find the previous and next panels. I found this <a href="http://stackoverflow.com/questions/22659903/jquery-scroll-to-next-prev-section-by-keyup-keydown" target="_blank">stackoverflow answer</a> that seemed like it could be a solution. It used the <a href="https://github.com/customd/jquery-visible" target="_blank">jquery-visible plugin</a> to tell if a section was in view and then found next and previous based on that. However, after the better part of a day going down that path, I realized it wouldn&rsquo;t work for my needs. Before giving up, I asked another engineer if he had any idea how I could make this work (shout out, Kevin!). He said, &ldquo;Why don&rsquo;t you try using waypoints?&rdquo; YES! Why didn&rsquo;t I think of that?</p>

<p><a href="http://imakewebthings.com/waypoints/" target="_blank">Waypoints</a> is a great library that lets you trigger a function on scroll. I could make each section have its own waypoint where it gets the class &lsquo;currentPanel&rsquo; as soon as it&rsquo;s almost to the top of the screen.</p>

<p>```javascript
getCurrentPanel: function() {
  var navHeight = $(&lsquo;header&rsquo;).outerHeight() &ndash; 1;</p>

<p>  $(&lsquo;section&rsquo;).each(function(){</p>

<pre><code>var index = $(this).index('section'),
    currentSection = $('section').get(index),
    nextSection = $(currentSection).next(),
    prevSection = $(currentSection).prev();
    currentPanelClass = 'current-panel';

var waypointsDown = new Waypoint({
  element: currentSection,
  handler: function(direction) {
    if (direction === 'down') {
      $(currentSection).addClass(currentPanelClass);
      if (prevSection.length &gt; 0) {
        prevSection.removeClass(currentPanelClass);
      }
    }
  },
  offset: 200
});
var waypointsUp = new Waypoint({
  element: currentSection,
  handler: function(direction) {
    if (direction === 'up') {
      $(currentSection).addClass(currentPanelClass);
      if ($(currentSection).length &gt; 0) {
        nextSection.removeClass(currentPanelClass);
      }
    }
  },
  offset: navHeight
});
</code></pre>

<p>  });
}
```</p>

<p>In that function, I&rsquo;m looping through all the sections and assigning a waypoint to each based on its index. As you&rsquo;re scrolling down, a section will get the class &lsquo;currentPanel&rsquo; when it&rsquo;s 200px from the top. On the way back up, a section would get that class as soon as it hits the nav. I&rsquo;m also making sure that as the &lsquo;currentPanel&rsquo; class is added to one section, it is removed from the section that just had it.</p>

<p>Now that I could find the current panel, I needed to designate next and previous panels and animate the scroll.</p>

<p>```javascript
findNext: function() {
  var that = this,</p>

<pre><code>  currentPanel = $('.current-panel'),
  nextPanel = currentPanel.next('section');
</code></pre>

<p>  if (nextPanel.length > 0) {</p>

<pre><code>that.scrollToElement(nextPanel);
</code></pre>

<p>  }
},</p>

<p>findPrev: function() {
  var that = this,</p>

<pre><code>  currentPanel = $('.current-panel'),
  prevPanel = currentPanel.prev('section');
</code></pre>

<p>  if (prevPanel.length > 0) {</p>

<pre><code>that.scrollToElement(prevPanel);
</code></pre>

<p>  }
},</p>

<p>scrollToElement: function(panel) {
  var navHeight = $(&lsquo;header&rsquo;).outerHeight();
  $(&lsquo;html, body&rsquo;).animate({</p>

<pre><code>scrollTop: panel.offset().top - navHeight
</code></pre>

<p>  }, 200);
}
```
Now I needed that scroll to happen in response to a presentation clicker. We had <a href="http://www.logitech.com/en-us/product/wireless-presenter-r400?crid=11" target="_blank">this one</a> in the office, so I connected it to my computer and console logged the <a href="https://css-tricks.com/snippets/javascript/javascript-keycodes/" target="_blank">keyCodes</a> to find which it simulated. It was using 33 and 34 (page up and page down). I also added a few more keyCodes in case the client forgot his clicker and needed to use the keyboard to move through the site.</p>

<p>```javascript
slider: function(e) {
  var that = this;
  $(document).on(&lsquo;keydown&rsquo;, function(e){</p>

<pre><code>var $currentPanel = $('.currentPanel');
if (e.keyCode === 40 || e.keyCode === 32 || e.keyCode === 13  || e.keyCode === 34 || e.keyCode === 39) {
  e.preventDefault();
  that.findNext();
} else if (e.keyCode === 38 || e.keyCode === 33 || e.keyCode === 37) {
  e.preventDefault();
  that.findPrev();
}
</code></pre>

<p>  });
}
```</p>

<p>Thanks to my &lsquo;getCurrentPanel&rsquo; function, I knew that the panel with the class &lsquo;currentPanel&rsquo; was my current panel, and could fire my &lsquo;findNext&rsquo; or &lsquo;findPrev&rsquo; functions based on whether the keyCodes called for up or down movement. Yay!</p>

<p>On to what I call &lsquo;fragmented&rsquo; panels. By this I mean sections that call for a halt in the movement up and down and instead move through the content inside the panel itself. We&rsquo;re also looking out for a <code>fragment-subnav</code> if it has one. All the fragmented examples in my demo site have subnavs. They give a great visual cue that there are other fragments and lets the user easily navigate them. But a subnav is not required.</p>

<p>```javascript
fragmentedPanel: function(movement) {
  var that = this,</p>

<pre><code>  currentFragmentedPanel = $('.current-panel.fragmented'),
  currentFragmentedParts = currentFragmentedPanel.find('.fragmented-part.active');
</code></pre>

<p>  currentFragmentedParts.each(function(){</p>

<pre><code>var fragmentIndex = $(this).index('.current-panel .fragmented-part'),
    fragment = $('.current-panel .fragmented-part').get(fragmentIndex),
    nextFragment = $(fragment).next(),
    prevFragment = $(fragment).prev(),
    checkForLast = nextFragment.next(),
    checkForFirst = fragmentIndex - 2,
    hasSubnav = currentFragmentedPanel.find('.fragment-subnav').length;
if (hasSubnav) {
  var activeSubnav = $('.current-panel .fragment-subnav.active'),
      nextSubnav = $('.current-panel .fragment-subnav').get(fragmentIndex + 1),
      prevSubnav = $('.current-panel .fragment-subnav').get(fragmentIndex - 1);
}
if (movement === 'down' &amp;&amp; nextFragment.length &gt; 0) {
  if (checkForLast.length &gt; 0) {
    currentFragmentedParts.removeClass('active');
    nextFragment.addClass('active');
    currentFragmentedPanel.removeClass('first-fragment');
    currentFragmentedPanel.removeClass('last-fragment');
    if (hasSubnav) {
      activeSubnav.removeClass('active');
      $(nextSubnav).addClass('active');
    }
  } else {
    currentFragmentedParts.removeClass('active');
    nextFragment.addClass('active');
    currentFragmentedPanel.removeClass('first-fragment');
    currentFragmentedPanel.addClass('last-fragment');
    if (hasSubnav) {
      activeSubnav.removeClass('active');
      $(nextSubnav).addClass('active');
    }
  }
} else if (movement === 'up' &amp;&amp; prevFragment.length &gt; 0) {
  if (checkForFirst &gt;= 0) {
    currentFragmentedParts.removeClass('active');
    prevFragment.addClass('active');
    currentFragmentedPanel.removeClass('first-fragment').removeClass('last-fragment');
    if (hasSubnav) {
      activeSubnav.removeClass('active');
      $(prevSubnav).addClass('active');
    }
  } else {
    currentFragmentedParts.removeClass('active');
    prevFragment.addClass('active');
    currentFragmentedPanel.removeClass('last-fragment').addClass('first-fragment');
    if (hasSubnav) {
      activeSubnav.removeClass('active');
      $(prevSubnav).addClass('active');
    }
  }
}
</code></pre>

<p>  });
}
```
For the code in your fragmented sections to work, you need to set up your HTML with certain classes. The &lsquo;section&rsquo; will need to get the classes &lsquo;fragmented&rsquo; and &lsquo;first-fragment&rsquo;. The fragments within your fragmented section need to get the class &lsquo;fragmented-part&rsquo;. The subnav items should get the class &lsquo;fragment-subnav&rsquo;. And the first fragment item and first subnav item should always get the &lsquo;active&rsquo; class.
Here&rsquo;s an example of how to set up the HTML:</p>

<p>```html
<section class="fragmented first-fragment">
  <!-- this is a slide with fragments -->
  <div class="fragmented-part active"></div>
  <div class="fragmented-part"></div>
  <div class="fragmented-part"></div>
</section></p>

<p><section class="fragmented first-fragment">
  <!-- this is a slide with fragments and a subnav-->
  <div class="fragment-subnav active"></div>
  <div class="fragment-subnav"></div>
  <div class="fragment-subnav"></div></p>

<p>  <div class="fragmented-part active"></div>
  <div class="fragmented-part"></div>
  <div class="fragmented-part"></div>
</section>
```</p>

<p>A big thing in the fragmentedPanel function is to know when you&rsquo;re reaching the end of the fragmented-parts so you can move on to the next slide. That&rsquo;s why I have the &lsquo;checkForLast&rsquo; and &lsquo;checkForFirst&rsquo; variables. With every movement, I&rsquo;m checking to see if an element exists in the next slot.</p>

<p>Great, now we need to update our slider function to halt movement if we see a &lsquo;fragmented&rsquo; section.</p>

<p>```javascript
slider: function(e) {
  var that = this;
  $(document).on(&lsquo;keydown&rsquo;, function(e){</p>

<pre><code>var $currentPanel = $('.currentPanel');
if (e.keyCode === 40 || e.keyCode === 32 || e.keyCode === 13  || e.keyCode === 34 || e.keyCode === 39) {
  e.preventDefault();
  if (currentPanel.hasClass('fragmented') &amp;&amp; !(currentPanel.hasClass('last-fragment'))) {
    that.fragmentedPanel('down');
  } else {
    that.findNext();
  }
} else if (e.keyCode === 38 || e.keyCode === 33 || e.keyCode === 37) {
  e.preventDefault();
  if ( currentPanel.hasClass('fragmented') &amp;&amp; !(currentPanel.hasClass('first-fragment')) ) {
    that.fragmentedPanel('up');
  } else {
    that.findPrev();
  }
}
</code></pre>

<p>  });
}
```</p>

<p>That&rsquo;s pretty much it. I hope this makes some kind of sense to you. You can take a look at the <a href="https://github.com/ccmeyers/slide-presentation" target="_blank">full code here</a> and a <a href="http://anunexpectedcoder.com/slide-presentation/" target="_blank">demo here</a>.</p>

<p>And in honor of this blog post&rsquo;s title. I leave you with a little Coolio circa 1994.</p>

<iframe width="420" height="315" src="https://www.youtube.com/embed/cbhkuu4e0iw" frameborder="0" allowfullscreen></iframe>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Premature Ajaxulation]]></title>
    <link href="http://anunexpectedcoder.com/blog/2014/08/09/premature-ajaxulation/"/>
    <updated>2014-08-09T21:01:10-07:00</updated>
    <id>http://anunexpectedcoder.com/blog/2014/08/09/premature-ajaxulation</id>
    <content type="html"><![CDATA[<h2>Don&rsquo;t worry, it happens to a lot of functions</h2>

<p>Recently, while building an app that used a lot of ajax calls, we kept on running into the problem of an ajax call firing before the function above it finished. Given that the function above provided variables that were necessary in our ajax call, this broke everything.</p>

<p>My team and I scoured the internet (i.e. stack overflow) for an answer, but came up with nothing. We finally asked a Flatiron School TA, and she gave a us a great solution.</p>

<p>We were building an app that calculates the half-way point of a given route. Then, we used the latitude and longitude of that point to search the Yelp API. The ajax call helps us get our javascript variables to the ruby method that directly deals with the API. And, here&rsquo;s what it looks like:</p>

<p>```javascript
var check_done = &ldquo;not done&rdquo;</p>

<p>function getStopPoint(response, percentage) {
  var totalDist = response.routes[0].legs[0].distance.value,</p>

<pre><code>  totalTime = response.routes[0].legs[0].duration.value,
  distance = (percentage/100) * totalDist,
  time = ((percentage/100) * totalTime/60).toFixed(2),
  polyline = new google.maps.Polyline({
    path: [],
    strokeColor: '#FF0000',
    strokeWeight: 3
  });
  var bounds = new google.maps.LatLngBounds();
  var steps = response.routes[0].legs[0].steps;
  for (j=0; j&lt;steps.length; j++) {
    var nextSegment = steps[j].path;
    for (k=0; k&lt;nextSegment.length; k++) {
      polyline.getPath().push(nextSegment[k]);
      bounds.extend(nextSegment[k]);
    }
  }
</code></pre>

<p>  stopPointLatLonObject = polyline.GetPointAtDistance(distance);
  placeMarker(stopPointLatLonObject);
  stopPointLat = stopPointLatLonObject[&ldquo;d&rdquo;];
  stopPointLon = stopPointLatLonObject[&ldquo;e&rdquo;];
  check_done = &ldquo;done&rdquo;;
}</p>

<p>function check(){
  if (check_done === &ldquo;done&rdquo;){</p>

<pre><code>$.ajax({
   url:'/restaurants/yelp_search', 
   type: 'POST',
   data:(
     'lat=' + stopPointLat + '&amp;' +
     'lon=' + stopPointLon + '&amp;' +
     'type=' + $("#type").val() + '&amp;' +
     'sort=' + $("#sort").val() + '&amp;' +
     'mtd=' + $("#mtd").val()
   )
});
</code></pre>

<p>  } else {</p>

<pre><code>setTimeout(check, 1000);
</code></pre>

<p>  }
}
```</p>

<p>The getStopPoint function goes through the polyline (we&rsquo;re dealing with the lovely Google Maps API here) and finds the stopping point. The most important part of the getStopPoint function is where we define our stopPointLat and stopPointLon variables. Those are the lat/lng coordinates we&rsquo;re going to send to the Yelp API via the ajax call. But, alas, alack! All is going to break if the ajax train leaves the station without its lat/lng coordinates!</p>

<p>How we went about fixing this was by using a check_done variable that is set to &ldquo;not done&rdquo; when it is defined. It only changes to &ldquo;done&rdquo; once stopPointLat and stopPointLon have their values. We use an if/else statement inside the check function to make sure that check_done === &ldquo;done&rdquo; before we send off our ajax call. Else, we setTimeout and run the check function all over again.</p>

<p>I hope that helps anyone out there who might have this problem!</p>
]]></content>
  </entry>
  
</feed>
