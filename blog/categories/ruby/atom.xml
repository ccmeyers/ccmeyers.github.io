<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | An Unexpected Coder]]></title>
  <link href="http://anunexpectedcoder.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://anunexpectedcoder.com/"/>
  <updated>2016-03-09T13:56:22-05:00</updated>
  <id>http://anunexpectedcoder.com/</id>
  <author>
    <name><![CDATA[Catherine Meyers]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Zip It, and Zip it Good]]></title>
    <link href="http://anunexpectedcoder.com/blog/2014/08/13/zip-it/"/>
    <updated>2014-08-13T19:42:16-04:00</updated>
    <id>http://anunexpectedcoder.com/blog/2014/08/13/zip-it</id>
    <content type="html"><![CDATA[<p>Sometimes scraping can be a complete pain when the site you&rsquo;re dealing with is poorly structured. While trying to scrape composers and their respective musical pieces from a site, we ran into a problem because a composer&rsquo;s pieces were not nested within that composer. Enter the ZIP method, the coolest method I had never heard of that I found out about today.</p>

<p>Here&rsquo;s an example of the html structure we were dealing with:
```html</p>

<div lang="en" dir="ltr" class="mw-content-ltr">
  <p><b>Alejandre Prada, Manuel</b></p>

  <dl>
    <dd>Suite, Op.44</dd>
  </dl>

  <p><b>Barthe, Adrien</b></p>

  <dl>
    <dd>Aubade</dd>
  </dl>
</div>


<p><code>
It was easy to grab the composers and pieces seperately:
</code>ruby
composers = @doc.css(&lsquo;div.mw-content-ltr p&rsquo;)
  #=>[#&lt;Nokogiri::XML::Element:0x816eb2a8 name=&ldquo;p&rdquo; children=[#&lt;Nokogiri::XML::Element:0x816eb0c8 name=&ldquo;b&rdquo; children=[#&lt;Nokogiri::XML::Text:0x816eaee8 &ldquo;Alejandre Prada, Manuel&rdquo;>]>, #&lt;Nokogiri::XML::Text:0x816ead44 &ldquo;\n&rdquo;>]>, #&lt;Nokogiri::XML::Element:0x816ef894 name=&ldquo;p&rdquo; children=[#&lt;Nokogiri::XML::Element:0x816ef6b4 name=&ldquo;b&rdquo; children=[#&lt;Nokogiri::XML::Text:0x816ef4d4 &ldquo;Barthe, Adrien&rdquo;>]
pieces = @doc.css(&lsquo;div.mw-content-ltr dl&rsquo;)
  #=>[#&lt;Nokogiri::XML::Element:0x816eaaec name=&ldquo;dl&rdquo; children=[#&lt;Nokogiri::XML::Element:0x816ea90c name=&ldquo;dd&rdquo; children=[#&lt;Nokogiri::XML::Text:0x816ea72c &ldquo; &rdquo;>, #&lt;Nokogiri::XML::Element:0x816ea678 name=&ldquo;a&rdquo; attributes=[#&lt;Nokogiri::XML::Attr:0x816ea614 name=&ldquo;href&rdquo; value=&ldquo;/wiki/Suite,<em>Op.44</em>(Alejandre_Prada,<em>Manuel)&rdquo;>, #&lt;Nokogiri::XML::Attr:0x816ea600 name=&ldquo;title&rdquo; value=&ldquo;Suite, Op.44 (Alejandre Prada, Manuel)&rdquo;>, #&lt;Nokogiri::XML::Attr:0x816ea5ec name=&ldquo;class&rdquo; value=&ldquo;mw-redirect&rdquo;>] children=[#&lt;Nokogiri::XML::Text:0x816efd80 &ldquo;Suite, Op.44&rdquo;>]>, #&lt;Nokogiri::XML::Text:0x816efbdc &ldquo;\n&rdquo;>]>]>, #&lt;Nokogiri::XML::Element:0x816ef0d8 name=&ldquo;dl&rdquo; children=[#&lt;Nokogiri::XML::Element:0x816eeef8 name=&ldquo;dd&rdquo; children=[#&lt;Nokogiri::XML::Text:0x816eed18 &ldquo; &rdquo;>, #&lt;Nokogiri::XML::Element:0x816eec64 name=&ldquo;a&rdquo; attributes=[#&lt;Nokogiri::XML::Attr:0x816eec00 name=&ldquo;href&rdquo; value=&ldquo;/wiki/Aubade</em>(Barthe,_Adrien)&rdquo;>, #&lt;Nokogiri::XML::Attr:0x816eebec name=&ldquo;title&rdquo; value=&ldquo;Aubade (Barthe, Adrien)&rdquo;>] children=[#&lt;Nokogiri::XML::Text:0x816ee5ac &ldquo;Aubade&rdquo;>]>, #&lt;Nokogiri::XML::Text:0x816ee408 &ldquo;\n&rdquo;>]>]>,
<code>
And iterate through them, putting the text into arrays:
</code>ruby
composers_names = composers.collect {|e|e.text.gsub(&ldquo;\n&rdquo;, &ldquo;&rdquo;)}
  #=>[&ldquo;Alejandre Prada, Manuel&rdquo;, &ldquo;Barthe, Adrien&rdquo;]
pieces_names = pieces.collect {|e|e.text}
  #=>[&ldquo; Suite, Op.44&rdquo;, &ldquo; Aubade&rdquo;]
<code>
Then, we had to put these two arrays back together! So...we zipped 'em!
</code>ruby
composers_pieces = composers_names.zip(pieces_names)
  #=>[[&ldquo;Alejandre Prada, Manuel&rdquo;, &ldquo; Suite, Op.44&rdquo;], [&ldquo;Barthe, Adrien&rdquo;, &ldquo; Aubade&rdquo;]]
<code>
Hooray! We now have paired the correct piece with the correct composer. All we had to do then was iterate through our arrays to create hashes: assigning array[0] as the key and array[1..-1] as the value. We needed [1..-1] because sometimes a composer has multiple pieces.
</code>ruby
composers_pieces.collect {|array| {array[0] => array[1..-1]}}
  #=> [{&ldquo;Alejandre Prada, Manuel&rdquo;=>[&ldquo; Suite, Op.44&rdquo;]}, {&ldquo;Barthe, Adrien&rdquo;=>[&ldquo; Aubade&rdquo;]}]
```
From there it was easy to save the key as the composer and the value as that composer&rsquo;s piece. Thank you to my team members for their help with this today. Shout out to <a href="http://rebeccagreenblatt.github.io/">Rebecca Greenblatt</a> and <a href="http://wlowry88.github.io/">Will Lowry</a>!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Iterators Schmiterators]]></title>
    <link href="http://anunexpectedcoder.com/blog/2014/06/25/iterators-schmiterators/"/>
    <updated>2014-06-25T15:32:49-04:00</updated>
    <id>http://anunexpectedcoder.com/blog/2014/06/25/iterators-schmiterators</id>
    <content type="html"><![CDATA[<h2>Choosing Between Each, Map, Collect, Select, or Detect</h2>

<p>Sometimes it can be confusing for a ruby newbie to know what method to use when iterating over an array or hash. Most tutorials focus on the each method like a prized first child and then gloss over the others. That can leave a lot of newbies writing extra code trying to make the each method work when they could use a different iterator with more ease.</p>

<p>The easiest way to decide which iterator to use is to ask yourself a few questions about the block of code you are passing in your iteration.</p>

<p><img class="center" src="/images/Iterator_Tree.jpg" width="750" height="750" title="&lsquo;Iterator Tree&rsquo; &lsquo;Iterator Tree&rsquo;" ></p>

<p>The first question is, &ldquo;Are you &lsquo;puts'ing elements?&rdquo; For that, you would want to use 'each&rsquo; so that you can simply puts without altering the original array.</p>

<p><code>ruby
array = [1,2,3,4]
array.each { |n| puts "The number is #{n}."}
  #=&gt; The number is 1.
  #   The number is 2.
  #   The number is 3.
  #   The number is 4.
</code>
If you aren&rsquo;t &lsquo;puts'ing elements, you need to ask, &ldquo;Do you want to pass each element through the block and then return a new array or hash?&rdquo; The key words here are 'return a new array or hash&rsquo;. The &lsquo;each&rsquo; method won&rsquo;t do that. It will just return the old array or hash no matter what you do with the elements in the block. If you know you want to create a new array or hash, you have to then ask, &ldquo;Are you only evaluating truthiness?&rdquo; If you are, &lsquo;select&rsquo; or &lsquo;detect&rsquo; are the way to go.
<code>ruby
array.select { |n| n.odd? }
  #=&gt; [1,3]
array.detect { |n| n.odd? }
  #=&gt; 1
</code>
&lsquo;Select&rsquo; will return an array of all the elements that evaluate to true, while &lsquo;detect&rsquo; will return only the first element that evaluates to true.</p>

<p>If you want to create a new array or hash AND you are doing something other than evaluating truthiness, you&rsquo;ll want to use &lsquo;map&rsquo; or &lsquo;collect&rsquo;. These two do the same thing. The only differences being: you have four less characters to type with &lsquo;map&rsquo;, but &lsquo;collect&rsquo; describes a bit better what you are actually doing. Choose as you will.
<code>ruby
array.collect { |n| n*10 }
  #=&gt; [10, 20, 30, 40]
</code>
One piece of advice: beware of sandwich coding. This happens if you are trying to use &lsquo;each&rsquo; where you want to use &lsquo;map&rsquo;/&lsquo;collect&rsquo;.
<code>ruby
new_array = []
array.each { |n| new_array &lt;&lt; n*10 }
new_array
  #=&gt; [10, 20, 30, 40]
</code>
You see how I had to add two extra lines to set up the variable as an empty array and then call the variable after the code was passed? Those lines are the bread to the &lsquo;each&rsquo; meat. Avoid this. Even if you love sandwiches. I love sandwiches.</p>
]]></content>
  </entry>
  
</feed>
