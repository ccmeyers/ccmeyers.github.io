<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Keynote | An Unexpected Coder]]></title>
  <link href="http://anunexpectedcoder.com/blog/categories/keynote/atom.xml" rel="self"/>
  <link href="http://anunexpectedcoder.com/"/>
  <updated>2016-03-09T13:56:22-05:00</updated>
  <id>http://anunexpectedcoder.com/</id>
  <author>
    <name><![CDATA[Catherine Meyers]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Slide Slide Slippity Slide]]></title>
    <link href="http://anunexpectedcoder.com/blog/2015/09/23/slide-slide-slippity-slide/"/>
    <updated>2015-09-23T16:47:44-04:00</updated>
    <id>http://anunexpectedcoder.com/blog/2015/09/23/slide-slide-slippity-slide</id>
    <content type="html"><![CDATA[<h2>How to Create a Slide Presentation in less than 200 Lines of JavaScript</h2>

<p>Recently a client needed a website that could be used both as a presentation tool (like a Keynote or PowerPoint presentation) and as a stand-alone website to be sent to possible investors to scroll through.</p>

<p>There are a lot of great libraries out there that help you mimic the functionality of a Keynote presentation. I took a look at <a href="http://flowtime-js.marcolago.com/" target="_blank">flowtime</a>, <a href="http://lab.hakim.se/reveal-js/#/" target="_blank">reveal.js</a>, and <a href="http://impress.github.io/impress.js/#/bored" target="_blank">impress.js</a>. But, these libraries are big and seemed like overkill for what I needed to do. Also, I really wanted to see if I could build this on my own.</p>

<p>(If you want to jump ahead to the finished product, here&rsquo;s <a href="http://anunexpectedcoder.com/slide-presentation/" target="_blank">an example</a> of what I built along with <a href="https://github.com/ccmeyers/slide-presentation" target="_blank">the code on github</a>.)</p>

<p>First I made my panels. I broke up the site into sections (literally &mdash; using <code>&lt;section&gt;&lt;/section&gt;</code> tags) and made each section <code>height = 100vh</code>. Actually, I had to make room for my fixed nav up top, so it was really <code>height = calc(100vh - 103)</code>. Now that I had things looking the way they should, I needed to make them act the way they should.</p>

<p>I soon realized that my biggest challenge was to designate which section was the current panel so we could find the previous and next panels. I found this <a href="http://stackoverflow.com/questions/22659903/jquery-scroll-to-next-prev-section-by-keyup-keydown" target="_blank">stackoverflow answer</a> that seemed like it could be a solution. It used the <a href="https://github.com/customd/jquery-visible" target="_blank">jquery-visible plugin</a> to tell if a section was in view and then found next and previous based on that. However, after the better part of a day going down that path, I realized it wouldn&rsquo;t work for my needs. Before giving up, I asked another engineer if he had any idea how I could make this work (shout out, Kevin!). He said, &ldquo;Why don&rsquo;t you try using waypoints?&rdquo; YES! Why didn&rsquo;t I think of that?</p>

<p><a href="http://imakewebthings.com/waypoints/" target="_blank">Waypoints</a> is a great library that lets you trigger a function on scroll. I could make each section have its own waypoint where it gets the class &lsquo;currentPanel&rsquo; as soon as it&rsquo;s almost to the top of the screen.</p>

<p>```javascript
  $(&lsquo;section&rsquo;).each(function(){</p>

<pre><code>var index = $(this).index('section'),
    currentSection = $('.section'+index),
    nextSection = currentSection.next(),
    prevSection = currentSection.prev();
    currentPanelClass = 'current-panel';
var waypointsDown = new Waypoint({
  element: currentSection,
  handler: function(direction) {
    if (direction === 'down') {
      currentSection.addClass(currentPanelClass);
      if (prevSection.length &gt; 0) {
        prevSection.removeClass(currentPanelClass);
      }
    }
  },
  offset: 200
});
var waypointsUp = new Waypoint({
  element: currentSection,
  handler: function(direction) {
    if (direction === 'up') {
      currentSection.addClass(currentPanelClass);
      if (currentSection.length &gt; 0) {
        nextSection.removeClass(currentPanelClass);
      }
    }
  },
  offset: 100
});
</code></pre>

<p>  });
}
```</p>

<p>In that function, I&rsquo;m looping through all the sections and assigning a waypoint to each based on its index. I set up my HTML so that each <code>&lt;section&gt;</code> had a class based on its position (i.e. the first section has a class of &lsquo;section0&rsquo;). As you&rsquo;re scrolling down, a section will get the class &lsquo;currentPanel&rsquo; when it&rsquo;s 200px from the top. On the way back up, a section would get that class 100px from the top. I&rsquo;m also making sure that as the &lsquo;currentPanel&rsquo; class is added to one section, it is removed from the section that just had it.</p>

<p>Now that I could find the current panel, I needed to designate next and previous panels and animate the scroll.</p>

<p>```javascript
scrollToElement: function(panel) {
  $(&lsquo;html, body&rsquo;).animate({</p>

<pre><code>scrollTop: panel.offset().top - 102
</code></pre>

<p>  }, 200);
},</p>

<p>findNext: function() {
  var that = this,</p>

<pre><code>  currentPanel = $('.current-panel'),
  nextPanel = currentPanel.next('section');
</code></pre>

<p>  if (nextPanel.length > 0) {</p>

<pre><code>that.scrollToElement(nextPanel);
</code></pre>

<p>  }
},</p>

<p>findPrev: function() {
  var that = this,</p>

<pre><code>  currentPanel = $('.current-panel'),
  prevPanel = currentPanel.prev('section');
</code></pre>

<p>  if (prevPanel.length > 0) {</p>

<pre><code>that.scrollToElement(prevPanel);
</code></pre>

<p>  }
}
```
Now I needed that scroll to happen in response to a presentation clicker. We had <a href="http://www.logitech.com/en-us/product/wireless-presenter-r400?crid=11" target="_blank">this one</a> in the office, so I connected it to my computer and console logged the <a href="https://css-tricks.com/snippets/javascript/javascript-keycodes/" target="_blank">keyCodes</a> to find which it simulated. It was using 33 and 34 (page up and page down). I also added a few more keyCodes in case the client forgot his clicker and needed to use the keyboard to move through the site.</p>

<p>```javascript
slider: function(e) {
  var that = this;
  $(document).on(&lsquo;keydown&rsquo;, function(e){</p>

<pre><code>var $currentPanel = $('.currentPanel');
if (e.keyCode === 40 || e.keyCode === 32 || e.keyCode === 13  || e.keyCode === 34 || e.keyCode === 39) {
  e.preventDefault();
  that.findNext();
} else if (e.keyCode === 38 || e.keyCode === 33 || e.keyCode === 37) {
  e.preventDefault();
  that.findPrev();
}
</code></pre>

<p>  });
}
```</p>

<p>Thanks to my &lsquo;getCurrentPanel&rsquo; function, I knew that the panel with the class &lsquo;currentPanel&rsquo; was my current panel, and could fire my &lsquo;findNext&rsquo; or &lsquo;findPrev&rsquo; functions based on whether the keyCodes called for up or down movement. Yay!</p>

<p>On to what I call &lsquo;fragmented&rsquo; panels. By this I mean sections that call for a halt in the movement up and down and instead move through the content inside the panel itself.</p>

<p>```javascript
fragmentedPanel: function(movement) {
  var that = this,</p>

<pre><code>  currentFragmentedPanel = $('.current-panel.fragmented'),
  currentFragmentedParts = currentFragmentedPanel.find('.fragmented-part.active');
</code></pre>

<p>  currentFragmentedParts.each(function(){</p>

<pre><code>var fragmentIndex = $(this).index('.current-panel .fragmented-part'),
    nextFragment = $('.current-panel .fragmented-part.part'+fragmentIndex).next(),
    prevFragment = $('.current-panel .fragmented-part.part'+fragmentIndex).prev(),
    checkForLast = nextFragment.next(),
    checkForFirst = fragmentIndex - 2;
if (movement === 'down' &amp;&amp; nextFragment.length &gt; 0) {
  if (checkForLast.length &gt; 0) {
    currentFragmentedParts.removeClass('active');
    nextFragment.addClass('active');
    currentFragmentedPanel.removeClass('first-fragment');
    currentFragmentedPanel.removeClass('last-fragment');
  } else {
    currentFragmentedParts.removeClass('active');
    nextFragment.addClass('active');
    currentFragmentedPanel.removeClass('first-fragment');
    currentFragmentedPanel.addClass('last-fragment');
  }
} else if (movement === 'up' &amp;&amp; prevFragment.length &gt; 0) {
  if (checkForFirst &gt;= 0) {
    currentFragmentedParts.removeClass('active');
    prevFragment.addClass('active');
    currentFragmentedPanel.removeClass('first-fragment').removeClass('last-fragment');
  } else {
    currentFragmentedParts.removeClass('active');
    prevFragment.addClass('active');
    currentFragmentedPanel.removeClass('last-fragment').addClass('first-fragment');
  }
}
</code></pre>

<p>  });
}
```</p>

<p>For this code to work, you need to set up your HTML with certain classes. The &lsquo;section&rsquo; will need to get the classes &lsquo;fragmented&rsquo; and &lsquo;first-fragment&rsquo;. The parts within that fragmented section need to get two classes: &lsquo;fragmented-part&rsquo; and part+index (i.e. &lsquo;part0&rsquo;). Here&rsquo;s an example of how to set up the HTML:</p>

<p><code>html
&lt;section class="section0"&gt;
  &lt;!-- this is a slide without fragments --&gt;
&lt;/section&gt;
&lt;section class="section1 fragmented first-fragment"&gt;
  &lt;!-- this is a slide with fragments --&gt;
  &lt;div class="fragmented-part part0 active"&gt;&lt;/div&gt;
  &lt;div class="fragmented-part part1"&gt;&lt;/div&gt;
  &lt;div class="fragmented-part part2"&gt;&lt;/div&gt;
&lt;/section&gt;
</code></p>

<p>A big thing in the fragmentedPanel function is to know when you&rsquo;re reaching the end of the fragmented-parts so you can move on to the next slide. That&rsquo;s why I have the &lsquo;checkForLast&rsquo; and &lsquo;checkForFirst&rsquo; variables. With every movement, I&rsquo;m checking to see if an element exists in the next slot.</p>

<p>Great, now we need to update our slider function to halt movement if we see a &lsquo;fragmented&rsquo; section.</p>

<p>```javascript
slider: function(e) {
  var that = this;
  $(document).on(&lsquo;keydown&rsquo;, function(e){</p>

<pre><code>var $currentPanel = $('.currentPanel');
if (e.keyCode === 40 || e.keyCode === 32 || e.keyCode === 13  || e.keyCode === 34 || e.keyCode === 39) {
  e.preventDefault();
  if (currentPanel.hasClass('fragmented') &amp;&amp; !(currentPanel.hasClass('last-fragment'))) {
    that.fragmentedPanel('down');
  } else {
    that.findNext();
  }
} else if (e.keyCode === 38 || e.keyCode === 33 || e.keyCode === 37) {
  e.preventDefault();
  if ( currentPanel.hasClass('fragmented') &amp;&amp; !(currentPanel.hasClass('first-fragment')) ) {
    that.fragmentedPanel('up');
  } else {
    that.findPrev();
  }
}
</code></pre>

<p>  });
}
```</p>

<p>That&rsquo;s pretty much it. I hope this makes some kind of sense to you. You can take a look at the <a href="https://github.com/ccmeyers/slide-presentation" target="_blank">full code here</a> and a <a href="http://anunexpectedcoder.com/slide-presentation/" target="_blank">demo here</a>.</p>

<p>And in honor of this blog post&rsquo;s title. I leave you with a little Coolio circa 1994.</p>

<iframe width="420" height="315" src="https://www.youtube.com/embed/cbhkuu4e0iw" frameborder="0" allowfullscreen></iframe>

]]></content>
  </entry>
  
</feed>
