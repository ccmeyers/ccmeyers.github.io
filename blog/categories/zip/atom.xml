<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: zip | An Unexpected Coder]]></title>
  <link href="http://anunexpectedcoder.com/blog/categories/zip/atom.xml" rel="self"/>
  <link href="http://anunexpectedcoder.com/"/>
  <updated>2016-03-09T13:56:22-05:00</updated>
  <id>http://anunexpectedcoder.com/</id>
  <author>
    <name><![CDATA[Catherine Meyers]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Zip It, and Zip it Good]]></title>
    <link href="http://anunexpectedcoder.com/blog/2014/08/13/zip-it/"/>
    <updated>2014-08-13T19:42:16-04:00</updated>
    <id>http://anunexpectedcoder.com/blog/2014/08/13/zip-it</id>
    <content type="html"><![CDATA[<p>Sometimes scraping can be a complete pain when the site you&rsquo;re dealing with is poorly structured. While trying to scrape composers and their respective musical pieces from a site, we ran into a problem because a composer&rsquo;s pieces were not nested within that composer. Enter the ZIP method, the coolest method I had never heard of that I found out about today.</p>

<p>Here&rsquo;s an example of the html structure we were dealing with:
```html</p>

<div lang="en" dir="ltr" class="mw-content-ltr">
  <p><b>Alejandre Prada, Manuel</b></p>

  <dl>
    <dd>Suite, Op.44</dd>
  </dl>

  <p><b>Barthe, Adrien</b></p>

  <dl>
    <dd>Aubade</dd>
  </dl>
</div>


<p><code>
It was easy to grab the composers and pieces seperately:
</code>ruby
composers = @doc.css(&lsquo;div.mw-content-ltr p&rsquo;)
  #=>[#&lt;Nokogiri::XML::Element:0x816eb2a8 name=&ldquo;p&rdquo; children=[#&lt;Nokogiri::XML::Element:0x816eb0c8 name=&ldquo;b&rdquo; children=[#&lt;Nokogiri::XML::Text:0x816eaee8 &ldquo;Alejandre Prada, Manuel&rdquo;>]>, #&lt;Nokogiri::XML::Text:0x816ead44 &ldquo;\n&rdquo;>]>, #&lt;Nokogiri::XML::Element:0x816ef894 name=&ldquo;p&rdquo; children=[#&lt;Nokogiri::XML::Element:0x816ef6b4 name=&ldquo;b&rdquo; children=[#&lt;Nokogiri::XML::Text:0x816ef4d4 &ldquo;Barthe, Adrien&rdquo;>]
pieces = @doc.css(&lsquo;div.mw-content-ltr dl&rsquo;)
  #=>[#&lt;Nokogiri::XML::Element:0x816eaaec name=&ldquo;dl&rdquo; children=[#&lt;Nokogiri::XML::Element:0x816ea90c name=&ldquo;dd&rdquo; children=[#&lt;Nokogiri::XML::Text:0x816ea72c &ldquo; &rdquo;>, #&lt;Nokogiri::XML::Element:0x816ea678 name=&ldquo;a&rdquo; attributes=[#&lt;Nokogiri::XML::Attr:0x816ea614 name=&ldquo;href&rdquo; value=&ldquo;/wiki/Suite,<em>Op.44</em>(Alejandre_Prada,<em>Manuel)&rdquo;>, #&lt;Nokogiri::XML::Attr:0x816ea600 name=&ldquo;title&rdquo; value=&ldquo;Suite, Op.44 (Alejandre Prada, Manuel)&rdquo;>, #&lt;Nokogiri::XML::Attr:0x816ea5ec name=&ldquo;class&rdquo; value=&ldquo;mw-redirect&rdquo;>] children=[#&lt;Nokogiri::XML::Text:0x816efd80 &ldquo;Suite, Op.44&rdquo;>]>, #&lt;Nokogiri::XML::Text:0x816efbdc &ldquo;\n&rdquo;>]>]>, #&lt;Nokogiri::XML::Element:0x816ef0d8 name=&ldquo;dl&rdquo; children=[#&lt;Nokogiri::XML::Element:0x816eeef8 name=&ldquo;dd&rdquo; children=[#&lt;Nokogiri::XML::Text:0x816eed18 &ldquo; &rdquo;>, #&lt;Nokogiri::XML::Element:0x816eec64 name=&ldquo;a&rdquo; attributes=[#&lt;Nokogiri::XML::Attr:0x816eec00 name=&ldquo;href&rdquo; value=&ldquo;/wiki/Aubade</em>(Barthe,_Adrien)&rdquo;>, #&lt;Nokogiri::XML::Attr:0x816eebec name=&ldquo;title&rdquo; value=&ldquo;Aubade (Barthe, Adrien)&rdquo;>] children=[#&lt;Nokogiri::XML::Text:0x816ee5ac &ldquo;Aubade&rdquo;>]>, #&lt;Nokogiri::XML::Text:0x816ee408 &ldquo;\n&rdquo;>]>]>,
<code>
And iterate through them, putting the text into arrays:
</code>ruby
composers_names = composers.collect {|e|e.text.gsub(&ldquo;\n&rdquo;, &ldquo;&rdquo;)}
  #=>[&ldquo;Alejandre Prada, Manuel&rdquo;, &ldquo;Barthe, Adrien&rdquo;]
pieces_names = pieces.collect {|e|e.text}
  #=>[&ldquo; Suite, Op.44&rdquo;, &ldquo; Aubade&rdquo;]
<code>
Then, we had to put these two arrays back together! So...we zipped 'em!
</code>ruby
composers_pieces = composers_names.zip(pieces_names)
  #=>[[&ldquo;Alejandre Prada, Manuel&rdquo;, &ldquo; Suite, Op.44&rdquo;], [&ldquo;Barthe, Adrien&rdquo;, &ldquo; Aubade&rdquo;]]
<code>
Hooray! We now have paired the correct piece with the correct composer. All we had to do then was iterate through our arrays to create hashes: assigning array[0] as the key and array[1..-1] as the value. We needed [1..-1] because sometimes a composer has multiple pieces.
</code>ruby
composers_pieces.collect {|array| {array[0] => array[1..-1]}}
  #=> [{&ldquo;Alejandre Prada, Manuel&rdquo;=>[&ldquo; Suite, Op.44&rdquo;]}, {&ldquo;Barthe, Adrien&rdquo;=>[&ldquo; Aubade&rdquo;]}]
```
From there it was easy to save the key as the composer and the value as that composer&rsquo;s piece. Thank you to my team members for their help with this today. Shout out to <a href="http://rebeccagreenblatt.github.io/">Rebecca Greenblatt</a> and <a href="http://wlowry88.github.io/">Will Lowry</a>!</p>
]]></content>
  </entry>
  
</feed>
